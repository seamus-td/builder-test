import { Builder } from '@builder.io/sdk';
import * as i0 from '@angular/core';
import { InjectionToken, Injectable, Optional, Inject, EventEmitter, Component, ChangeDetectionStrategy, Input, Output, makeStateKey, Directive, PLATFORM_ID, NgModule } from '@angular/core';
import * as i3$1 from '@angular/common';
import { isPlatformBrowser, CommonModule } from '@angular/common';
import * as i1 from '@angular/common/http';
import * as i3 from '@angular/router';
import { NavigationEnd } from '@angular/router';
import { Subscription, BehaviorSubject } from 'rxjs';
import * as i1$1 from '@angular/platform-browser';

// Modified from @webcomponentsjs but fixed so uglifyjs can run (remove `const` keyword)
// Original source: https://github.com/webcomponents/custom-elements/blob/master/src/native-shim.js
// Issue: https://github.com/webcomponents/webcomponentsjs/issues/749
if (typeof window !== 'undefined') {
    const anyWindow = window;
    if (!(undefined === anyWindow.Reflect ||
        undefined === anyWindow.customElements ||
        anyWindow.customElements.polyfillWrapFlushCallback)) {
        try {
            const ModifiedHTMLElement = HTMLElement;
            // https://github.com/webcomponents/custom-elements/blame/c078ea4201c82551462ccace1ae91e22b576beb8/src/native-shim.js#L37
            const wrapperForTheName = {
                HTMLElement: function HTMLElement() {
                    return Reflect.construct(ModifiedHTMLElement, [], this.constructor);
                },
            };
            anyWindow.HTMLElement = wrapperForTheName['HTMLElement'];
            HTMLElement.prototype = ModifiedHTMLElement.prototype;
            HTMLElement.prototype.constructor = HTMLElement;
            Object.setPrototypeOf(HTMLElement, ModifiedHTMLElement);
        }
        catch (e) { }
    }
}

const REQUEST = new InjectionToken('REQUEST');
const RESPONSE = new InjectionToken('RESPONSE');

const BUILDER_API_KEY = 'BUILDER_API_KEY'; // new InjectionToken<string>('BUILDER_API_KEY');
const EXPRESS_REQUEST = 'EXPRESS_REQUEST'; // new InjectionToken<Request>('EXPRESS_REQUEST');
const EXPRESS_RESPONSE = 'EXPRESS_RESPONSE'; // new InjectionToken<Response>('EXPRESS_RESPONSE');
class BuilderService extends Builder {
    expressRequest;
    expressEngineRequest;
    expressResponse;
    expressEngineResponse;
    http;
    static componentInstances = {};
    autoTrack = !this.isDevelopment;
    // TODO: set this for QA
    get isDevelopment() {
        // Automatic determining of development environment
        return (Builder.isIframe ||
            (Builder.isBrowser && (location.hostname === 'localhost' || location.port !== '')));
    }
    constructor(apiKey, expressRequest, expressEngineRequest, expressResponse, expressEngineResponse, http) {
        super(apiKey, expressEngineRequest || expressRequest, expressEngineResponse || expressResponse);
        this.expressRequest = expressRequest;
        this.expressEngineRequest = expressEngineRequest;
        this.expressResponse = expressResponse;
        this.expressEngineResponse = expressEngineResponse;
        this.http = http;
        if (this.expressEngineRequest) {
            this.expressRequest = this.expressEngineRequest;
        }
        if (this.expressRequest) {
            this.request = this.expressRequest;
        }
        if (this.expressEngineResponse) {
            this.expressResponse = this.expressEngineResponse;
        }
        if (this.expressResponse) {
            this.response = this.expressResponse;
        }
        if (apiKey) {
            this.apiVersion = 'v3';
            this.init(apiKey);
        }
        if (!Builder.isBrowser && !this.request) {
            console.warn('No express request set! Builder cannot target appropriately without this, ' +
                'please contact support@builder.io to learn how to set this as required');
        }
    }
    // (override)
    requestUrl(url) {
        if (this.http) {
            return this.http.get(url).toPromise();
        }
        else {
            return super.requestUrl(url);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.6", ngImport: i0, type: BuilderService, deps: [{ token: BUILDER_API_KEY, optional: true }, { token: EXPRESS_REQUEST, optional: true }, { token: REQUEST, optional: true }, { token: EXPRESS_RESPONSE, optional: true }, { token: RESPONSE, optional: true }, { token: i1.HttpClient, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.0.6", ngImport: i0, type: BuilderService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.6", ngImport: i0, type: BuilderService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [BUILDER_API_KEY]
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [EXPRESS_REQUEST]
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [REQUEST]
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [EXPRESS_RESPONSE]
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [RESPONSE]
                }] }, { type: i1.HttpClient, decorators: [{
                    type: Optional
                }] }] });

class BuilderComponentService {
    contentComponentInstance = null;
    contentDirectiveInstance = null;
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.6", ngImport: i0, type: BuilderComponentService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.0.6", ngImport: i0, type: BuilderComponentService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.6", ngImport: i0, type: BuilderComponentService, decorators: [{
            type: Injectable
        }] });

class BuilderContentComponent {
    element;
    builderComponentService;
    constructor(element, builderComponentService) {
        this.element = element;
        this.builderComponentService = builderComponentService;
        builderComponentService.contentComponentInstance = this;
    }
    modelName;
    useHtml = false;
    data = {};
    hydrate = true;
    prerender = true;
    set content(content) {
        const currentContent = this._content;
        this._content = content;
        const { contentDirectiveInstance } = this.builderComponentService;
        if (!currentContent && content && contentDirectiveInstance) {
            if (!contentDirectiveInstance.requesting) {
                contentDirectiveInstance.reset();
            }
        }
    }
    get content() {
        return this._content;
    }
    _content;
    findAndRunScripts() {
        if (!Builder.isBrowser) {
            return;
        }
        const el = this.element.nativeElement;
        if (el) {
            const scripts = el.getElementsByTagName('script');
            for (let i = 0; i < scripts.length; i++) {
                const script = scripts[i];
                if (script.src) {
                    const newScript = document.createElement('script');
                    newScript.async = true;
                    newScript.src = script.src;
                    document.head.appendChild(newScript);
                }
                else {
                    try {
                        new Function(script.innerText)();
                    }
                    catch (error) {
                        console.warn('Builder custom code component error:', error);
                    }
                }
            }
        }
    }
    options = null;
    contentLoad = new EventEmitter();
    contentError = new EventEmitter();
    get editingMode() {
        return Builder.editingPage;
    }
    ngOnInit() {
        const modelName = this.element.nativeElement &&
            this.element.nativeElement.getAttribute &&
            this.element.nativeElement.getAttribute('builder-model');
        if (modelName) {
            // FIXME: doesn't work on server!
            this.modelName = modelName;
            BuilderService.componentInstances[modelName] = this;
        }
    }
    ngOnDestroy() {
        if (this.modelName) {
            if (BuilderService.componentInstances[this.modelName] === this) {
                delete BuilderService.componentInstances[this.modelName];
            }
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.6", ngImport: i0, type: BuilderContentComponent, deps: [{ token: i0.ElementRef }, { token: BuilderComponentService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.0.6", type: BuilderContentComponent, selector: "builder-content", inputs: { useHtml: "useHtml", data: "data", hydrate: "hydrate", prerender: "prerender", content: "content", options: "options" }, outputs: { contentLoad: "contentLoad", contentError: "contentError" }, ngImport: i0, template: "<ng-content> </ng-content>\n", styles: [":host{display:block}\n"], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.6", ngImport: i0, type: BuilderContentComponent, decorators: [{
            type: Component,
            args: [{ selector: 'builder-content', changeDetection: ChangeDetectionStrategy.OnPush, template: "<ng-content> </ng-content>\n", styles: [":host{display:block}\n"] }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: BuilderComponentService }], propDecorators: { useHtml: [{
                type: Input
            }], data: [{
                type: Input
            }], hydrate: [{
                type: Input
            }], prerender: [{
                type: Input
            }], content: [{
                type: Input
            }], options: [{
                type: Input
            }], contentLoad: [{
                type: Output
            }], contentError: [{
                type: Output
            }] } });

class BuilderContentService {
    componentInstance = null;
    directiveInstance = null;
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.6", ngImport: i0, type: BuilderContentService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.0.6", ngImport: i0, type: BuilderContentService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.6", ngImport: i0, type: BuilderContentService, decorators: [{
            type: Injectable
        }] });

class BuilderContentDirective {
    _viewContainer;
    renderer;
    builder;
    builderComponentService;
    transferState;
    router;
    get component() {
        // return BuilderService.componentInstances[this._context.model as string];
        return this.builderComponentService.contentComponentInstance;
    }
    lastContentId = null;
    lastUrl = null;
    subscriptions = new Subscription();
    _context = new BuilderContentContext();
    _templateRef = null;
    _viewRef = null;
    // private _repeat = false;
    match;
    matchId = '';
    clickTracked = false;
    hydrated = false;
    constructor(_viewContainer, renderer, builder, builderComponentService, transferState, templateRef, router) {
        this._viewContainer = _viewContainer;
        this.renderer = renderer;
        this.builder = builder;
        this.builderComponentService = builderComponentService;
        this.transferState = transferState;
        this.router = router;
        builderComponentService.contentDirectiveInstance = this;
        this._templateRef = templateRef;
    }
    // TODO: pass this option down from builder-component
    reloadOnRoute = true;
    contentSubscription = null;
    stateKey;
    requesting = true;
    reset() {
        // TODO: listen to any target change? This just updates target?
        // TODO: track last fetched ID and don't replace dom if on new url the content is the same...
        this.clickTracked = false;
        this.hydrated = false;
        // Verify the route didn't result in this component being destroyed
        this.request();
    }
    ngOnInit() {
        Builder.nextTick(() => {
            this.request();
        });
        if (this.router) {
            this.subscriptions.add(this.router.events.subscribe((event) => {
                // TODO: this doesn't trigger
                if (event instanceof NavigationEnd) {
                    if (this.reloadOnRoute) {
                        const viewRef = this._viewRef;
                        if (viewRef && viewRef.destroyed) {
                            return;
                        }
                        if (this.url !== this.lastUrl) {
                            this.reset();
                        }
                    }
                }
            }));
        }
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
        if (this.contentSubscription) {
            this.contentSubscription.unsubscribe();
        }
    }
    // TODO: have another option for this or get from metadata
    // @Input()
    // set modelMultiple(repeat: boolean) {
    //   this._repeat = repeat;
    // }
    // @HostListener('click')
    onClick(event) {
        if (this.matchId && !this.hydrated) {
            const match = this.match;
            if (this.builder.autoTrack) {
                this.builder.trackInteraction(this.matchId, match && match.variationId, this.clickTracked, event, { content: match });
            }
            this.clickTracked = true;
        }
        // TODO: only in editor mode
        // TODO: put messaging on builder class
        if (document.body.classList.contains('builder-editing')) {
            if (this.matchId) {
                // TODO: get event object and pass mouse coordinages
                window.parent.postMessage({
                    type: 'builder.clickContent',
                    data: {
                        id: this.matchId,
                        model: this._context.model,
                    },
                }, '*');
            }
            else {
                window.parent.postMessage({
                    type: 'builder.clickModel',
                    data: {
                        model: this._context.model,
                    },
                }, '*');
            }
        }
    }
    get stateKeyString() {
        return 'builder:' + this._context.model + ':' + (this.reloadOnRoute ? this.url : '');
    }
    // TODO: limit?
    // TODO: context with index, etc
    set builderModel(model) {
        if (!model) {
            return;
        }
        this._context.model = model;
        this._updateView();
        this.stateKey = makeStateKey(this.stateKeyString);
        // this.request();
        const rootNode = this._viewRef.rootNodes[0];
        this.renderer.setAttribute(rootNode, 'builder-model', model);
        this.renderer.setAttribute(rootNode, 'builder-model-name', model.replace(/-/g, ' '));
        this.renderer.listen(rootNode, 'click', (event) => this.onClick(event));
    }
    get url() {
        const location = this.builder.getLocation();
        return location.pathname || ''; // + (location.search || '');
    }
    // TODO: service for this
    request() {
        this.lastUrl = this.url;
        this.requesting = true;
        if (this.component && !this.component.prerender) {
            return;
        }
        const viewRef = this._viewRef;
        if (viewRef && viewRef.destroyed) {
            return;
        }
        let receivedFirstResponse = false;
        const model = this._context.model;
        const options = this.component && this.component.options;
        const initialContent = (this.component && this.component.content) ||
            (Builder.isBrowser &&
                // firstEverLoad &&
                this.transferState &&
                this.transferState.get(this.stateKeyString, null));
        // firstEverLoad = false;
        // TODO: if not multipe
        if (this.contentSubscription) {
            // TODO: cancel a request if one is pending... or set some kind of flag
            this.contentSubscription.unsubscribe();
        }
        const hydrate = Builder.isBrowser && this.component && this.component.hydrate;
        const key = Builder.isEditing || !this.reloadOnRoute ? model : `${model}:${this.url}`;
        const subscription = (this.contentSubscription = this.builder
            .queueGetContent(model, {
            initialContent,
            key,
            ...options,
            prerender: true,
            static: !hydrate,
        })
            .subscribe((result) => {
            let match = result[0];
            // Cancel handling request if new one created or they have been canceled, to avoid race conditions
            // if multiple routes or other events happen
            if (this.contentSubscription !== subscription) {
                if (!receivedFirstResponse) {
                }
                return;
            }
            if (match && match.id === this.lastContentId) {
                return;
            }
            this.lastContentId = match && match.id;
            if (this.transferState && !Builder.isBrowser) {
                this.transferState.set(this.stateKeyString, result);
            }
            // tslint:disable-next-line:no-non-null-assertion
            const viewRef = this._viewRef;
            if (viewRef.destroyed) {
                this.subscriptions.unsubscribe();
                if (this.contentSubscription) {
                    this.contentSubscription.unsubscribe();
                }
                return;
            }
            const rootNode = Builder.isBrowser && viewRef.rootNodes[0];
            if (Builder.isBrowser) {
                if (rootNode) {
                    if (rootNode && rootNode.classList.contains('builder-editor-injected')) {
                        viewRef.detach();
                        return;
                    }
                }
            }
            // FIXME: nasty hack to detect secondary updates vs original. Build proper support into JS SDK
            // if (this._context.loading || result.length > viewRef.context.results.length) {
            this._context.loading = false;
            const search = this.builder.getLocation().search || '';
            // TODO: how handle singleton vs multiple
            if (!match && search.includes('builder.preview=' + this._context.model)) {
                match = {
                    id: 'preview',
                    name: 'Preview',
                    data: {},
                };
            }
            if (this.component) {
                this.component.contentLoad.next(match);
            }
            else {
                console.warn('No component!');
            }
            if (match) {
                const rootNode = this._viewRef.rootNodes[0];
                this.matchId = match.id;
                this.renderer.setAttribute(rootNode, 'builder-content-entry-id', match.id);
                this.match = match;
                viewRef.context.$implicit = match.data;
                viewRef.context.meta = match.meta;
                // viewRef.context.results = result.map(item => ({ ...item.data, $id: item.id }));
                if (!hydrate && this.builder.autoTrack) {
                    this.builder.trackImpression(match.id, match.variationId, undefined, {
                        content: match,
                    });
                }
            }
            if (!viewRef.destroyed) {
                viewRef.detectChanges();
                if (this.builderComponentService.contentComponentInstance &&
                    this.builderComponentService.contentComponentInstance.prerender &&
                    Builder.isBrowser &&
                    Builder.isStatic) {
                    Builder.nextTick(() => {
                        if (this.builderComponentService.contentComponentInstance) {
                            this.builderComponentService.contentComponentInstance.findAndRunScripts();
                        }
                    });
                }
                // TODO: it's possible we don't want anything below to run if this has been destroyed
                if (match && match.data && match.data.animations && Builder.isBrowser && !hydrate) {
                    Builder.nextTick(() => {
                        Builder.animator.bindAnimations(match.data.animations);
                    });
                }
            }
            if (!receivedFirstResponse) {
                receivedFirstResponse = true;
            }
        }, (error) => {
            if (this.component) {
                this.component.contentError.next(error);
            }
            else {
                console.warn('No component!');
            }
            if (!receivedFirstResponse) {
                // TODO: how to zone error
                receivedFirstResponse = true;
            }
        }));
    }
    _updateView() {
        if (this._context.model) {
            this._viewContainer.clear();
            if (this._templateRef) {
                this._viewRef = this._viewContainer.createEmbeddedView(this._templateRef, this._context);
            }
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.6", ngImport: i0, type: BuilderContentDirective, deps: [{ token: i0.ViewContainerRef }, { token: i0.Renderer2 }, { token: BuilderService }, { token: BuilderComponentService }, { token: i0.TransferState, optional: true }, { token: i0.TemplateRef }, { token: i3.Router, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.0.6", type: BuilderContentDirective, selector: "[builderModel]", inputs: { reloadOnRoute: "reloadOnRoute", builderModel: "builderModel" }, providers: [BuilderContentService], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.6", ngImport: i0, type: BuilderContentDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[builderModel]',
                    providers: [BuilderContentService],
                }]
        }], ctorParameters: () => [{ type: i0.ViewContainerRef }, { type: i0.Renderer2 }, { type: BuilderService }, { type: BuilderComponentService }, { type: i0.TransferState, decorators: [{
                    type: Optional
                }] }, { type: i0.TemplateRef }, { type: i3.Router, decorators: [{
                    type: Optional
                }] }], propDecorators: { reloadOnRoute: [{
                type: Input
            }], builderModel: [{
                type: Input
            }] } });
class BuilderContentContext {
    $implicit;
    match;
    model;
    loading = true;
    results = [];
    meta;
}

class BuilderBlocksComponent {
    domSanitizer;
    builder;
    blocks;
    child = false;
    prerender = true;
    model = '';
    key = '';
    options = null;
    // @deprecated
    field = '';
    breakpoints;
    constructor(domSanitizer, builder) {
        this.domSanitizer = domSanitizer;
        this.builder = builder;
    }
    lastInnerHtml = '';
    lastInnerHtmlSanitized = null;
    get hasNoChildren() {
        return !(this.blocks && (this.blocks.length || this.blocks.html));
    }
    get arrayBlocks() {
        return Array.isArray(this.blocks);
    }
    get innerHtml() {
        const html = this._innerHtml;
        if (html === this.lastInnerHtml) {
            return this.lastInnerHtmlSanitized || '';
        }
        this.lastInnerHtml = html;
        this.lastInnerHtmlSanitized = this.domSanitizer.bypassSecurityTrustHtml(html);
        return this.lastInnerHtmlSanitized;
    }
    get _innerHtml() {
        // TODO: pass options too
        if (!this.prerender || Builder.isEditing) {
            return `<builder-component-element prerender="false" ${!this.model ? '' : `name="${this.model}"`}></builder-component-element>`;
        }
        const elStr = `<builder-component-element prerender="false" ${!this.model ? '' : `name="${this.model}"`}></builder-component-element>`;
        if (this.arrayBlocks || !this.blocks) {
            return elStr;
        }
        if (!this.blocks.html) {
            return elStr;
        }
        const css = this.blocks.css;
        let html = this.blocks.html;
        if (this.breakpoints) {
            if (this.breakpoints.small) {
                html = html.replace(/max-width:640/g, `max-width:${this.breakpoints.small}`);
            }
            if (this.breakpoints.medium) {
                html = html.replace(/max-width:991/g, `max-width:${this.breakpoints.medium}`);
            }
        }
        if (css) {
            html = `<style class="builder-styles">${css}</style>` + html;
        }
        return `<builder-component-element key="${this.key || this.model}" options='${JSON.stringify(this.options || null // TODO: HTML encode
        )}' prerender="false" rev="${this.blocks.rev || ''}" ${!this.model ? '' : `name="${this.model}"`}>${html}</builder-component-element>`;
    }
    trackByFn(index, value) {
        // TODO: possibly json-stable-stringify
        return value.id || (value.component && value.component.id) || JSON.stringify(value);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.6", ngImport: i0, type: BuilderBlocksComponent, deps: [{ token: i1$1.DomSanitizer }, { token: BuilderService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.0.6", type: BuilderBlocksComponent, selector: "builder-blocks", inputs: { blocks: "blocks", child: "child", prerender: "prerender", model: "model", key: "key", options: "options", field: "field", breakpoints: "breakpoints" }, ngImport: i0, template: "<div class=\"builder-blocks builder-blocks-html\">\n  <div [innerHTML]=\"innerHtml\"></div>\n</div>\n", styles: [""], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.6", ngImport: i0, type: BuilderBlocksComponent, decorators: [{
            type: Component,
            args: [{ selector: 'builder-blocks', changeDetection: ChangeDetectionStrategy.OnPush, template: "<div class=\"builder-blocks builder-blocks-html\">\n  <div [innerHTML]=\"innerHtml\"></div>\n</div>\n" }]
        }], ctorParameters: () => [{ type: i1$1.DomSanitizer }, { type: BuilderService }], propDecorators: { blocks: [{
                type: Input
            }], child: [{
                type: Input
            }], prerender: [{
                type: Input
            }], model: [{
                type: Input
            }], key: [{
                type: Input
            }], options: [{
                type: Input
            }], field: [{
                type: Input
            }], breakpoints: [{
                type: Input
            }] } });

class BuilderBlocksOutletComponent {
    domSanitizer;
    builderBlock;
    builderState;
    blocks;
    renderOnChange = true;
    dataPath;
    lastInnerHtml = '';
    lastInnerHtmlSanitized;
    get options() {
        return {
            child: true,
            parentElementId: this.builderBlock.id,
            blocks: this.blocks,
            dataPath: this.dataPath,
        };
    }
    get key() {
        return this.builderBlock.id + this.dataPath;
    }
    get innerHtml() {
        const html = this._innerHtml;
        if (html === this.lastInnerHtml) {
            return this.lastInnerHtmlSanitized || '';
        }
        this.lastInnerHtml = html;
        this.lastInnerHtmlSanitized = this.domSanitizer.bypassSecurityTrustHtml(html);
        return this.lastInnerHtmlSanitized;
    }
    get _innerHtml() {
        return `<builder-blocks-slot key="${this.key}"></builder-blocks-slot>`;
    }
    constructor(domSanitizer) {
        this.domSanitizer = domSanitizer;
    }
    ngAfterViewInit() {
        if (Builder.isBrowser) {
            this.triggerstateChange();
        }
    }
    async triggerstateChange() {
        const query = `builder-blocks-slot[key="${this.key}"]`;
        const element = document.querySelector(query);
        if (element) {
            await customElements.whenDefined('builder-blocks-slot');
            element.setProps(this.options, this.builderState);
        }
    }
    ngOnChanges(changes) {
        if (changes.blocks && this.renderOnChange) {
            this.triggerstateChange();
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.6", ngImport: i0, type: BuilderBlocksOutletComponent, deps: [{ token: i1$1.DomSanitizer }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.0.6", type: BuilderBlocksOutletComponent, selector: "builder-blocks-outlet", inputs: { builderBlock: "builderBlock", builderState: "builderState", blocks: "blocks", renderOnChange: "renderOnChange", dataPath: "dataPath" }, usesOnChanges: true, ngImport: i0, template: "<div [innerHTML]=\"innerHtml\"></div>\n", styles: [":host{display:block}\n"], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.6", ngImport: i0, type: BuilderBlocksOutletComponent, decorators: [{
            type: Component,
            args: [{ selector: 'builder-blocks-outlet', changeDetection: ChangeDetectionStrategy.OnPush, template: "<div [innerHTML]=\"innerHtml\"></div>\n", styles: [":host{display:block}\n"] }]
        }], ctorParameters: () => [{ type: i1$1.DomSanitizer }], propDecorators: { builderBlock: [{
                type: Input
            }], builderState: [{
                type: Input
            }], blocks: [{
                type: Input
            }], renderOnChange: [{
                type: Input
            }], dataPath: [{
                type: Input
            }] } });

// TODO remove hardcoded version, maybe a release tag?
const ANGULAR_LATEST_VERSION = '2.0.2';
const SCRIPT_ID = 'builder-wc-script';

function omit(obj, ...values) {
    const newObject = Object.assign({}, obj);
    for (const key of values) {
        delete newObject[key];
    }
    return newObject;
}
let wcScriptInserted = false;
const NAVIGATION_TIMEOUT_DEFAULT = 1000;
function delay(duration, resolveValue) {
    return new Promise((resolve) => setTimeout(() => resolve(resolveValue), duration));
}
class BuilderComponentComponent {
    viewContainer;
    elementRef;
    builderService;
    router;
    model;
    set name(name) {
        this.model = name;
    }
    handleRouting = true;
    reloadOnRoute = true;
    load = new EventEmitter();
    route = new EventEmitter();
    error = new EventEmitter();
    content = null;
    options = null;
    data = {};
    context = {};
    hydrate = true;
    prerender = true;
    // Sometimes user will have slow connection and when we are using Resolver on target route
    // then, application will be fully reloaded. In that case set it to false to avoid full-reload navigation.
    navigationTimeout = NAVIGATION_TIMEOUT_DEFAULT;
    subscriptions = new Subscription();
    visible = new BehaviorSubject(true);
    get url() {
        const location = this.builderService.getLocation();
        return location.pathname || '';
    }
    get key() {
        const key = Builder.isEditing || !this.reloadOnRoute ? this.model : `${this.model}:${this.url}`;
        return key;
    }
    constructor(viewContainer, elementRef, builderService, router) {
        this.viewContainer = viewContainer;
        this.elementRef = elementRef;
        this.builderService = builderService;
        this.router = router;
    }
    async ensureWCScriptLoaded() {
        if (!Builder.isBrowser || wcScriptInserted || document.getElementById(SCRIPT_ID)) {
            return;
        }
        function getQueryParam(url, variable) {
            const query = url.split('?')[1] || '';
            const vars = query.split('&');
            for (let i = 0; i < vars.length; i++) {
                const pair = vars[i].split('=');
                if (decodeURIComponent(pair[0]) === variable) {
                    return decodeURIComponent(pair[1]);
                }
            }
            return null;
        }
        const script = document.createElement('script');
        const wcVersion = getQueryParam(location.href, 'builder.wcVersion') || ANGULAR_LATEST_VERSION;
        script.id = SCRIPT_ID;
        // TODO: detect builder.wcVersion and if customEleemnts exists and do
        // dynamic versions and lite here
        script.src = `https://cdn.builder.io/js/webcomponents@${wcVersion || 'latest'}/dist/system/angular/builder-webcomponents-async.js`;
        script.async = true;
        wcScriptInserted = true;
        return new Promise((resolve, reject) => {
            script.addEventListener('load', resolve);
            script.addEventListener('error', (e) => reject(e.error));
            document.head.appendChild(script);
        });
    }
    async ensureWcLoadedAndUpdate() {
        await this.ensureWCScriptLoaded();
        const { onBuilderWcLoad } = window;
        if (onBuilderWcLoad) {
            onBuilderWcLoad((BuilderWC) => {
                const builder = BuilderWC.builder;
                builder.apiKey = this.builderService.apiKey;
                builder.canTrack = this.builderService.canTrack;
                builder.setUserAttributes(omit(this.builderService.getUserAttributes(), 'urlPath'));
                this.builderService.userAttributesChanged.subscribe((attrs) => builder.setUserAttributes(attrs));
                this.triggerstateChange();
            });
        }
    }
    ngOnInit() {
        if (this.router && this.reloadOnRoute) {
            // TODO: should the inner function return reloadOnRoute?
            this.router.routeReuseStrategy.shouldReuseRoute = () => false;
        }
        if (Builder.isBrowser) {
            if (this.router) {
                this.subscriptions.add(this.router.events.subscribe((event) => {
                    if (event instanceof NavigationEnd) {
                        if (this.reloadOnRoute) {
                            // Force reload component
                            this.visible.next(false);
                            Builder.nextTick(() => {
                                this.visible.next(true);
                            });
                        }
                    }
                }));
            }
            this.subscriptions.add(this.load.subscribe(async (value) => {
                // TODO: this may run constantly when editing - check on this, not
                // end of world but not ideal for perf
                this.viewContainer.detach();
                if (Builder.isEditing || (value && value.data && this.hydrate !== false)) {
                    await this.ensureWcLoadedAndUpdate();
                }
            }));
        }
        if (Builder.isBrowser && (this.hydrate !== false || Builder.isEditing)) {
            this.ensureWcLoadedAndUpdate();
        }
    }
    async triggerstateChange() {
        const query = `builder-component-element[name="${this.model}"]`;
        const element = document.querySelector(query);
        if (element) {
            customElements.whenDefined('builder-component-element').then(() => {
                element.setState(this.data);
                element.setContext(this.context);
            });
        }
    }
    ngOnChanges(changes) {
        if (changes.data) {
            this.triggerstateChange();
        }
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
    // TODO: this should be in BuilderBlocks
    async onClick(event) {
        if (!this.handleRouting) {
            return;
        }
        if (event.button !== 0 || event.ctrlKey || event.defaultPrevented) {
            // If this is a non-left click, or the user is holding ctr/cmd, or the url is absolute,
            // or if the link has a target attribute, don't route on the client and let the default
            // href property handle the navigation
            return;
        }
        const hrefTarget = this.findHrefTarget(event);
        if (!hrefTarget) {
            return;
        }
        // target="_blank" or target="_self" etc
        if (hrefTarget.target) {
            return;
        }
        let href = hrefTarget.getAttribute('href');
        if (!href) {
            return;
        }
        if (href.startsWith('javascript:')) {
            return;
        }
        const routeEvent = {
            url: href,
            anchorNode: hrefTarget,
            preventDefault() {
                this.defaultPrevented = true;
            },
            defaultPrevented: false,
        };
        this.route.next(routeEvent);
        if (routeEvent.defaultPrevented) {
            event.preventDefault();
            return;
        }
        if (event.metaKey) {
            return;
        }
        if (!this.isRelative(href)) {
            const converted = this.convertToRelative(href);
            if (converted) {
                href = converted;
            }
            else {
                return;
            }
        }
        if (!this.router) {
            return;
        }
        // Otherwise if this url is relative, navigate on the client
        event.preventDefault();
        // Attempt to route on the client
        let success = null;
        const routePromise = this.router.navigateByUrl(href);
        const useNavigationTimeout = !(typeof this.navigationTimeout === 'boolean' && !this.navigationTimeout);
        const timeoutPromise = delay(typeof this.navigationTimeout === 'number'
            ? this.navigationTimeout
            : NAVIGATION_TIMEOUT_DEFAULT, false);
        try {
            const promiseRace = useNavigationTimeout ? [timeoutPromise, routePromise] : [routePromise];
            success = await Promise.race(promiseRace);
        }
        finally {
            // This is in a click handler so it will only run on the client
            if (success) {
                // If successful scroll the window to the top
                window.scrollTo(0, 0);
            }
            else {
                // Otherwise handle the routing with a page refresh on failure. Angular, by deafult
                // if it fails to load a URL (e.g. if an API request failed when loading it), instead
                // of navigating to the new page to tell the user that their click did something but
                // the resulting page has an issue, it instead just silently fails and shows the user
                // nothing. Lets make sure we route to the new page. In some cases this even brings the
                // user to a correct and valid page anyway
                location.href = `${location.protocol}//${location.host}${href}`;
            }
        }
    }
    isRelative(href) {
        return (!href.match(/^(\/\/|https?:\/\/)/i) &&
            // Handle Mailto and Tel links
            !href.startsWith('tel:') &&
            !href.startsWith('mailto:') &&
            // Handle local hash links
            !href.startsWith('#'));
    }
    // Attempt to convert an absolute url to relative if possible (aka if the hosts match)
    convertToRelative(href) {
        const currentUrl = new URL(location.href);
        const hrefUrl = new URL(href);
        if (currentUrl.host === hrefUrl.host) {
            const relativeUrl = hrefUrl.pathname + (hrefUrl.search ? hrefUrl.search : '');
            return relativeUrl;
        }
    }
    findHrefTarget(event) {
        let element = event.target;
        while (element) {
            if (element instanceof HTMLAnchorElement && element.getAttribute('href')) {
                return element;
            }
            if (element === event.currentTarget) {
                break;
            }
            element = element.parentElement;
        }
        return null;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.6", ngImport: i0, type: BuilderComponentComponent, deps: [{ token: i0.ViewContainerRef }, { token: i0.ElementRef }, { token: BuilderService }, { token: i3.Router, optional: true }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.0.6", type: BuilderComponentComponent, selector: "builder-component", inputs: { model: "model", name: "name", handleRouting: "handleRouting", reloadOnRoute: "reloadOnRoute", content: "content", options: "options", data: "data", context: "context", hydrate: "hydrate", prerender: "prerender", navigationTimeout: "navigationTimeout" }, outputs: { load: "load", route: "route", error: "error" }, providers: [BuilderComponentService], usesOnChanges: true, ngImport: i0, template: "<span *ngIf=\"visible | async\" class=\"builder-component-wrap\">\n  <span *ngIf=\"!prerender\">\n    <builder-blocks\n      field=\"blocks\"\n      [key]=\"key\"\n      [model]=\"model\"\n      (click)=\"onClick($event)\"\n      [prerender]=\"false\"\n      [options]=\"options\"\n    ></builder-blocks>\n  </span>\n  <span *ngIf=\"prerender\">\n    <builder-content\n      [data]=\"data\"\n      [hydrate]=\"hydrate\"\n      [prerender]=\"prerender\"\n      [content]=\"content\"\n      [options]=\"options\"\n      (click)=\"onClick($event)\"\n      (contentLoad)=\"load.next($event)\"\n      (contentError)=\"error.next($event)\"\n      *builderModel=\"model; let content; let loading = loading; let meta = meta;\"\n    >\n      <builder-blocks\n        *ngIf=\"content\"\n        field=\"blocks\"\n        [key]=\"key\"\n        [model]=\"model\"\n        [prerender]=\"prerender\"\n        [options]=\"options\"\n        [blocks]=\"content.blocks || content\"\n        [breakpoints]=\"(content.meta && content.meta.breakpoints) || (meta && meta.breakpoints) || undefined\"\n      ></builder-blocks>\n      <ng-content *ngIf=\"loading\"></ng-content>\n    </builder-content>\n  </span>\n</span>\n", styles: [":host{display:block}\n"], dependencies: [{ kind: "directive", type: i3$1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: BuilderContentComponent, selector: "builder-content", inputs: ["useHtml", "data", "hydrate", "prerender", "content", "options"], outputs: ["contentLoad", "contentError"] }, { kind: "component", type: BuilderBlocksComponent, selector: "builder-blocks", inputs: ["blocks", "child", "prerender", "model", "key", "options", "field", "breakpoints"] }, { kind: "directive", type: BuilderContentDirective, selector: "[builderModel]", inputs: ["reloadOnRoute", "builderModel"] }, { kind: "pipe", type: i3$1.AsyncPipe, name: "async" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.6", ngImport: i0, type: BuilderComponentComponent, decorators: [{
            type: Component,
            args: [{ selector: 'builder-component', providers: [BuilderComponentService], changeDetection: ChangeDetectionStrategy.OnPush, template: "<span *ngIf=\"visible | async\" class=\"builder-component-wrap\">\n  <span *ngIf=\"!prerender\">\n    <builder-blocks\n      field=\"blocks\"\n      [key]=\"key\"\n      [model]=\"model\"\n      (click)=\"onClick($event)\"\n      [prerender]=\"false\"\n      [options]=\"options\"\n    ></builder-blocks>\n  </span>\n  <span *ngIf=\"prerender\">\n    <builder-content\n      [data]=\"data\"\n      [hydrate]=\"hydrate\"\n      [prerender]=\"prerender\"\n      [content]=\"content\"\n      [options]=\"options\"\n      (click)=\"onClick($event)\"\n      (contentLoad)=\"load.next($event)\"\n      (contentError)=\"error.next($event)\"\n      *builderModel=\"model; let content; let loading = loading; let meta = meta;\"\n    >\n      <builder-blocks\n        *ngIf=\"content\"\n        field=\"blocks\"\n        [key]=\"key\"\n        [model]=\"model\"\n        [prerender]=\"prerender\"\n        [options]=\"options\"\n        [blocks]=\"content.blocks || content\"\n        [breakpoints]=\"(content.meta && content.meta.breakpoints) || (meta && meta.breakpoints) || undefined\"\n      ></builder-blocks>\n      <ng-content *ngIf=\"loading\"></ng-content>\n    </builder-content>\n  </span>\n</span>\n", styles: [":host{display:block}\n"] }]
        }], ctorParameters: () => [{ type: i0.ViewContainerRef }, { type: i0.ElementRef }, { type: BuilderService }, { type: i3.Router, decorators: [{
                    type: Optional
                }] }], propDecorators: { model: [{
                type: Input
            }], name: [{
                type: Input
            }], handleRouting: [{
                type: Input
            }], reloadOnRoute: [{
                type: Input
            }], load: [{
                type: Output
            }], route: [{
                type: Output
            }], error: [{
                type: Output
            }], content: [{
                type: Input
            }], options: [{
                type: Input
            }], data: [{
                type: Input
            }], context: [{
                type: Input
            }], hydrate: [{
                type: Input
            }], prerender: [{
                type: Input
            }], navigationTimeout: [{
                type: Input
            }] } });

Builder.isStatic = true;
Builder.sdkInfo = {
    name: 'angular',
    version: '5.0.2',
};
if (typeof window !== 'undefined') {
    window.parent?.postMessage({
        type: 'builder.isAngularGen1Sdk',
        data: {
            // @ts-ignore
            version: '5.0.2',
        },
    }, '*');
}
const directives = [BuilderContentDirective];
const components = [
    BuilderContentComponent,
    BuilderBlocksComponent,
    BuilderComponentComponent,
    BuilderBlocksOutletComponent,
];
class BuilderModule {
    platformId;
    constructor(injector, platformId) {
        this.platformId = platformId;
        if (isPlatformBrowser(platformId)) {
            // This cannot use a normal import, via https://github.com/angular/angular/issues/24551
            // Cannot use require, so use import. This otherwise breaks at runtime
            import('@angular/elements').then(({ createCustomElement }) => {
                for (const component of Builder.components) {
                    if (component.class &&
                        component.type === 'angular' &&
                        component.tag &&
                        typeof customElements.get(component.tag) === 'undefined') {
                        try {
                            const Element = createCustomElement(component.class, { injector });
                            // Register the custom element with the browser.
                            customElements.define(component.tag, Element);
                        }
                        catch (err) {
                            console.warn('Could not make angular element:', component.class);
                        }
                    }
                }
            });
        }
    }
    static forRoot(apiKey) {
        return {
            ngModule: BuilderModule,
            providers: [
                {
                    provide: BUILDER_API_KEY,
                    useValue: apiKey,
                },
            ],
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.6", ngImport: i0, type: BuilderModule, deps: [{ token: i0.Injector }, { token: PLATFORM_ID }], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "18.0.6", ngImport: i0, type: BuilderModule, declarations: [BuilderContentComponent,
            BuilderBlocksComponent,
            BuilderComponentComponent,
            BuilderBlocksOutletComponent, BuilderContentDirective], imports: [CommonModule], exports: [BuilderContentComponent,
            BuilderBlocksComponent,
            BuilderComponentComponent,
            BuilderBlocksOutletComponent, BuilderContentDirective] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "18.0.6", ngImport: i0, type: BuilderModule, providers: [BuilderService, BuilderContentService, BuilderComponentService], imports: [CommonModule] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.6", ngImport: i0, type: BuilderModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    providers: [BuilderService, BuilderContentService, BuilderComponentService],
                    declarations: [components, directives],
                    exports: [components, directives],
                }]
        }], ctorParameters: () => [{ type: i0.Injector }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [PLATFORM_ID]
                }] }] });

function BuilderBlock(options) {
    options.type = 'angular';
    return Builder.Component(options);
}

/**
 * Generated bundle index. Do not edit.
 */

export { BUILDER_API_KEY, BuilderBlock, BuilderBlocksComponent, BuilderBlocksOutletComponent, BuilderComponentComponent, BuilderContentComponent, BuilderContentDirective, BuilderModule, BuilderService, EXPRESS_REQUEST, EXPRESS_RESPONSE };
//# sourceMappingURL=builder.io-angular.mjs.map
